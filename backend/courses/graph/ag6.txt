(1. Groitor rr . Graph >\lgorithms (1. (1roirorrr . Graph >\lgorirhms (1. (1roirorrr . Graph .'\lgorirhms
(.1. (.‘roitorrr - Graph Algorirhrrrs il‘ (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - Graph
Algorithms (1. (1r'oiior'rr - Graph Algorithms ’ (1. (Yroitorrr . Graph Algorithms (1. (".r'oirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgorirhrrrs' (.1. (.1roirorrr — Graph Algorithrrrs :1‘ (.1. (froitorrr
Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms ‘ (1. Groiror rr . Graph >\lgorirhms (1. (1roirorrr
- Graph Algorithms (.1. (.1roitorrr - Graph Algorithrrrs sl‘ (.1. (.1roirorrr - Graph Algorithms (.1.
('Iroiroru - Graph Algorithms (1'. (1roirorrr . Graph .-\lgrn'ithm.s (1. (1roitoru - Graph Algorithms‘ Z‘:
(.1. (.froitortr - Graph Algorithrris “ (.1. (.1roitorrr - Graph \lgorirhrrrs (.1. (.froirorrr — Graph Algorithrrrs
(1. (1roitorrr - Graph Algorithms Z" (I. (1roirorrr - Graph Algorithms (1. (1roitorrr - Graph
Algorithms “ (1. (“roirorrr . Graph \ ‘t " ' '1 (I air ‘ "raph \lgorithms (1. (“roirorrr .
Graph Algorithms (1. (.roirorrr - Glgrgllisggibtﬁrrrssbﬁgggigrorrr - Graph Algorithms (1. (.roirorrr
. Graph \lgor'ithms (1. ('Ir'oitorrr . Graph Algor irhms l (1. (1|oiror tr . Graph ‘\lgor ithms (1.
(froiroru ~ Graph Algorithms (.Q. (Qr'oiror'rr ~ Graph Algorithms (.1. (.froitoru ~ Graph Algorithms 2*
(1. ('Iroitor rr . Graph >\lgorithms (1. (1roirorrr . Graph Algor irhms (1. Groitor rr . Graph >\lgorithms
(.1. (froitor'rr - Graph Algoritlrrrrs *1 (.1. (.1roirorrr - Graph Algor ithms (.1. (.1r0itor tr - (.lraplr
>\lgorithms (1. (1roirorrr - Graph .'\lgorirhms ’ (1. Groirorrr . Graph >\lgorithm.s (1. ("Iroirorrr -
Graph Algorithrrrs “ (.1. (froitorrr - Graph \lgrirrirhrrrs' (.1. (.Irririrorrr — Graph Algorithrrrs “ (.1. (froitorrr
. Graph Algorithms (1. (1roitorrr - Graph Algorithms Z" (I. (1roitorrr . Graph Algorithms
—

—

By taking the logarithm in (*) we get

h('u) <10g(-pred[ﬁnd(v)]) g log n,Vv 6 V.
Therefore, the time complexity of the While loop is
C’)(n — 1+ 2mlog n) : 0(mlog n)

Hence, this second implementation of union and ﬁnd gives an @(m log n)

time complexity for the Kruskal’s algorithm.
—

Note that MG satisﬁes:
(i) 6 € Mg;
(ii) M 6M9,M’ Q M:>M’ 6M9.
Let M € MG be a matching.
o A vertex 'u G V with dM('u) : 1 is called saturated by M, and the
set of all vertices 0f G saturated by M is denoted S (M ) Obviously,
S(M) : U e, and |S(M)| : 2- |M|.
eEM
o A vertex 'u E V with dM('u) : 0 is called exposed with respect to
M (or unsaturated by M), and the set of all vertices of G exposed
to M is denoted E(M). Clearly, E(M) : V\S(M), and |E(M) :
IVI — 2 ~ IM l- v
—

Note that we have proved that the two problems P1 and P2 are polynomi-

ally equivalent since the matching M and the edge-cover F constructed

are optimal solutions, respectively.
—

Exercise 1. Let G : (V,E) be a connected graph and c : E —> R a

weight function on its edges. A subset A Q E is called cut if exists a

bipartion (S, T) of V such that A : {u'u G E: u G S,'u E T} (G\A

is no more connected).

(a) If in every cut it exists only one edge of minimum cost, then G
contains only one minimum cost spanning tree.

(b) Show that, if c is an injective function, then G contains only one
minimum cost spanning tree.

(c) Are true the reciprocal assertions?

Exercise 2. Let G : (V, E) be a connected graph 0f order n, c : E —> R,

and Tém" the family of its (c related) minimum cost spanning trees.

Deﬁne H z (ngm, E(H)) where T1T2 e E(H) <2 ]E(T1)AE(T2)\ I

2. Prove that H is connected and its diameter is at most n — 1.

—

Exercise 7. Consider an ordering E : {e1, e2, . . . , em} of the edges of a

connected graph G : (V, E) of order n. For every subset A Q E we

deﬁne XA G GFm its m-dimensional characteristic vector: x24 : 1 <:>
ei E A. GFm is the m-dimensional vector space over Z2.

(a) Show that the subset of the characteristic vectors corresponding to
all the cuts in G completed with zero vector is a subspace X of
GFm.

(b) Show that the subset of the characteristic vectors corresponding to
all the cycles in G spans a subspace U of GFm which is orthogonal
on X.

(c) Prove that dim(X) Z n — 1.

(d) Show that dim(U) 2 m — n +1.

(e) Finally, prove that the above inequalities are in fact equalities.

—

Exercise 15. Let X be a ﬁnite set, X1,...,Xn Q X, and d1, (L2,...dn E
N. Prove that there are n disjoint subsets Yi Q Xi, |Y¢| : di, Vi : Lin
if and only if

‘U%>Z%

1'61 zEI
for all I Q {1,...,'n,}.
Exercise 16. Every p-regular bipartite graph has a perfect matching
(P > 1)-
Exercise 17. Let G : (S, T; E) a bipartite graph. Use Hall’s theorem
to prove that, for every O g k g |S|, G has a matching of cardinality at
least |S| — k if and only if |Ng(A)| Z |A| — k, VA Q S.

—


o Minimum spanning tree (MST) problem
o MST general method
o Prim’s algorithm
o Kruskal’s Algorithm
e Matchings
o Maximum matchings — minimum edge-covers
o The Maximum Matching Problem
a Exercises for the 7th seminar (november 11 - 15 week)
—

If G : (V, E) is a connected graph With V : {1,2, . . . , n}, then Tlnil
constructed by the above algorithm is an MST of G. /
Proof: We prove (by induction) that (*) Vk; E {0, . . . , n — 1} there exists
a spanning tree Ti, MST of G, such that

nik

EW) I U MT?) c Em)-

izl
In particular, for k : n — 1, E(T"_1) I E(T1”’l) Q E(T,*,‘_1) implies
Tlnil : T:_1 and the theorem is proved.
For k; : O, we have E(TO) : Q and, since G is connected, there exists
a MST T5; therefore the property (*) holds.

J
—

o In Prim’s strategy Tsk is the maximum order tree in the family 7"“.

o It follows that in each step k > 0 of the general method, Tk has a
tree, Tf : (Vs, Es), with k + 1 vertices and n — k; — 1 trees each
containing just one vertex.

o Dijkstra’s implementation: Let a and ﬂ be two vectors of size n;
the elements of a are vertices from V(G) and the elements of l3 are
real numbers, with the following meaning:

(S) VJ 6 V\ Vsﬁlil I C(alJlJ) I Mir/13,1361? c(11)
‘hm. ﬁ..w.. ‘ﬁn. ﬁt...‘ ‘hm. m. J
—

o The sorting can be done in (9(mlog m) : (9(mlog n) time.

o In order to efficiently implement the test from the while loop,
it is necessary to represent the sets of vertices of the trees,
V(T1'°), V(T§), . . ., V(T,',°ik) (at each step k of the general
method), and to test if the current edge has both extremities in
the same set.

o These sets will be represented using trees (which are not, in general,
subtrees of the graph G). Each such tree has a root which will be
used to designate the set of vertices of the graph G stored in the
tree.

0 More precisely, we have a function ﬁnd('u) which ﬁnds the set to
which the vertex 'u belongs, that is, returns the root of the tree
storing the set to which 'u belongs. ‘

—

o The array pred[1..n] with entries from V LJ {0} has the meaning
pred[v] :the vertex before v on the unique path to v from the root
of the tree storing the set to which v belongs.

o Add to the initialization step (corresponding to the family To):

for ('u E V) do
pred['v] k O;
o The function ﬁnd('u) runs in (9(h(v)) time, where h('u) is
the length of the tree-path from v to the root (of its tree):
function ﬁnd('u : V);
i <— 'u;// a local variable.
While (predm > 0) do
2' k predh'];
return 2'; J
—

o The initialization step is
for ('u G V) do
pred['u] P —1;
o The procedure union takes also (9(1) time to maintain the new
meaning:
procedure union(r00t1, TOOtg : V)
t <— pred[root1] + pred[root2];
if (-pred[r00t1] 2 —pred[r00t2]) then
pred[r00t2] <— rootl; pred[r00t1] <— t;
else
pred[root1] P rootg; pred[r00t2] P t;
—

If A : N >< N —> N is the Ackermann function given by:
n + 1, if m : 0
(1) A(m,n): A(m—1,1), ifm >0 and 71:0
A(m— 1,A(m,n— 1)), ifm > O and n >0
and if we denote, Vm 2 n > 0,
a(m,n) : min{z : A(z,4[m/nl) >10gn,z >1}
we get that the time complexity of the While loop using union from the
second solution and the above ﬁnd, is (9(m - a(m, n)).
Note that a(m,n) is an extremely slow increasing function, and for
practical values of n a(m, n) g 3, hence, the third solution is practically
a linear implementation (C')('m)) of Kruskal’s algorithm. ,
—

(Norman-Rabin, 1959) Let G : (V, E) be a graph of order n, Without
isolated vertices. If M * is a maximum cardinality matching in G and F
is a minimum cardinality edge-cover in G, then
|M*| + |F*| : n.
Proof: "g" Let M * be a maximum cardinality matching in G and con-
sider the following algorithm:
F P M*;
for ('u G E(M*)) do
ﬁnd 'u’ € S(M*) s. t. 'u'u’ G E;
F <- F U {1111'};
—

The Maximum Matching Problem

Theorem 3 l

Theorem 4 \
Graph Algorithms — Lecture 6 November 8, 2024 37/49

Exercise 5. Let G : (V, E) be a connected graph and c : E —> R an
injective weight on its edges. Let us consider the following algorithm
for (e E E) do
7(6) k 7‘; // a11 the edges are colored red; during the execution they will
be red, blue or green
While ((EIA Q E, a cut, s. t. 7(e’) 5i g, Where c(e’) : miil c(e)) or
ee
(EIC, a cycle, s. t. 7(e’) 75 b, Where c(e’) : mag; c(e))) do
ee
for a cut, A, 7(e’) <— g;
for a cycle, C, 7(e’) P b;
return H : (V,{e G E : 'y(e) : 9});
Prove that
(a) an edge belongs to a minimum cost spanning tree if and only if it
is of minumum cost in a certain cut;
(b) an edge doesn’t belong to any minimum cost spanning tree of G if
and only if it is of maximum cost on a certain cycle;
—

Exercise 10. Let G : (V,E) be a connected graph and c : E —> IR

an injective cost function on its edges. Let T* be the minimum cost

spanning tree of G and To be a second-best minimum cost spanning

tree in G.

(a) Is To the only second-best minimum cost spanning tree in G?

(b) Prove that ]E(T*)AE(T0)] : 2.

(c) Devise an algorithm to ﬁnd the second-best minimum cost spanning
—


MST problem. Given G : (V, E) a graph and c : E —> IR (c(e) is the
cost of the edge e), ﬁnd T* E TG such that
T* I ' T
C( ) 71%17116 ¢( ),
where c(T) : Z c(e).
e€E(T)
—

Proof cont’d. If the property (*) holds for 0 g k g n — 2, then there

exists a MST of G, Tg‘, such that E(Tk) Q E(T,;*). By construction,

E(Tk+1) : E(Tk) U{e*}. If e* 6 E(T,’§), we then take T§+1 : Tl’: and

the property holds for k + 1.

Suppose that e* ¢ E(T,:) Then, T]: + e* has exactly one cycle C’,

containing e* : USU-7*. Since 'qu g2 V(Tsk), it follows that there exists

an edge e1 7i e* in C’ with an extremity in V(T$k) and the other in

V\ V(Tsk). By the choice of e* we have c(e*) g c(el) and e1 E

Eur) \ Eon-

Let T1 : T]: + e* — e1; obviously, T1 € TG (being connected with n — 1

edges).

Since 61 e E(T,j) \ E(Tk), we have E(Tk+1) g E(T1).
—

‘\3(1; U w
\‘ Mm) : 00
‘ ,
‘r
o Note that (S) is satisﬁed after the initializations. In the while loop,
the strategy of the general method is respected and the meaning of
(S) is maintained also by the test in the for loop.
o Time complexity: (9(n — 1) + (9(n — 2) + - - - + (9(1) : (9(n2) which
is good for graphs with size (9(n2).
J
—

o In the general method it is necessary to perform the (disjoint) union
of the vertex sets of two trees (in order to obtain 7%“).
0 We use a method uni0n('u,, w) with the following meaning: it per-
forms the union of the two sets of vertices, to which 'u and w belong.
o We can rewrite the while loop of the algorithm, using these two
methods, as follows:
while (z g m) do
let el- : 11w;
if (ﬁnd(v) 75 ﬁnd('w)) then
union('u, w);
T <- T U {61'};
z' + +; /
—

0 The method union (having time complexity (9(1)) is called only
for root vertices:
method unton(root1, rootg : V)
pred[r00t1] <- Tootg;
o The While loop of the algorithm is changed to support this
modiﬁcation:
While (z' g m) do
let e1: 'uw; a: <—_ﬁnd('u); 'y <—ﬁnd(w);
if (:1: 75 y) then
union(:z:, y);
T k T U {61'};
z' + +;
—

Fact. With these implementations of the function ﬁnd and method union
the algorithm has the following invariant:
(*)Vv G V, —p'red[ﬁnd('u)] 2 2M”)

In other words, the number of vertices stored in the tree to which 'u
belongs is at least 2 to the power IIdistance of 'u to the root".
Proof of the fact. After the initialization step we have h('u) : 0,
ﬁnd('u) : v, and —pred[v] : 1, V'u 6 V, therefore (*) holds with
equality.
Suppose that (*) holds before an iteration in the while loop. We have
two possible cases:

o In this while iteration union is not called. The array pred is not

updated, so (*) still holds after this iteration.
—

Let G : (V, E) be a (multi)graph. If A Q E and 'u E V, we denote
dA('u) : |{e : e G A, e incident with 'u}|, i. e., the degree of 'u in the
subgraph spanned by A, <A)G.
A matching (an independent set of edges) in G is any set of edges M Q E
such that
dM('u)<1,V'u E V.
The family of all matchings in the graph G is denoted Mgl
MG : {M : M Q E,M matching in G}.
—

Proof cont’d.
Since G has no isolated vertices, V'u E E(M*), there exists an edge
incident with 'u, and, since M * is maximal W. r. t. inclusion, this edge
has the other end in S(M*).
The set F of edges constructed is an edge-cover and |F| I |M*| +
|E(M*)| = |M*| + n — 2- |M*| : n — |M*| Hence
(2) |F*|<lFl:n—lM*l-
"Z" Let F* be minimum cardinality edge-cover in G and consider the
following algorithm:
M <- F*;
for (El'u E V: dM('u) > 1) do
ﬁnd e 6 M incident with 'u;
M P M \ {8}; ,
—

Exercise 1’. Find a minimum cost spanning tree in the following graph.
Y
x -1
2
3 Z
1
S
U
3
-1
w 0 V
—

Exercise 6 (cont’d).

(b) Let G : (V, E) be a connected graph with V : {1,2, . . . , n}, and
A Q V; we also have a cost function c : E —> Rn Consider the
complete graph Kn (with V(Kn) : V) and deﬁne E : E(Kn) —>
R+I

E(ij) : min c(P) : Z c(e) : P is ij-path in G
eEE(P)
Prove that s[T(G, A, 0)] : s[T(Kn, A,E)] and show how to build
a Steiner tree T(Kn, A,E) starting from a Steiner tree T(G, A, c).

(c) Show that it exists a Steiner tree T(Kn, A,E) such that all its ver-
tices from outside A has degree at least 3. Using this property prove
that there exists a Steiner tree T(Kn, A,E) having at most 2lA] — 2

—

Exercise 13. Two kids play the following game on a given graph G: they
alternatively pick a new vertex 110,111,. .. such that, for every i > 0, v,-
is adjacent with 11,-_1. The player which can not choose another vertex
will loose the game. Prove that the player which starts the game has
always a winning strategy if and only if G has not a perfect matching. ,
Exercise 14. Let S be a non-empty, ﬁnite set, k: E N*, and A : (A,)1<,<k
and B : (B¢)1<,<k two partitions of S. Prove that A and B admits a
common set of representatives, i. e., there exist 734,713 : {1,2, . . . , k} —>
S such that for every 1 g z' g k, 734(1) G A, and r5(z') G Bi, and the
two functions have the same image. ,
—


o Start with the family 7-0 : (T10, TS, . . . , T2) of n disjoint trees:
TlO : ({i}, Q), i: Lin.

o In each step k (0 g k: g n — 2), from the family Tk =
(le,T2k,...,Tf,f_k) of (n — k) disjoint trees such that V :
n—k n—k
U V(Tf) and U E(Tf) g E, deﬁne Tk+1 like follows:

1:1 1:1

o choose Tsk E Th;

o ﬁnd a minimum cost edge 6* : 'us'uje from the set of edges of G
with an extremity 'us E V(T$k) and the other in V\ V(T$k) ('uje E

k .

O Tk+1 I (Tk \ {T5, TJIZD U T, Where T is the tree obtained from

Tsk and T111 by adding the edge e*.
—

o The above proof remains true for tree-cost functions c : TG —> R
satisfying: VT G Tg,Ve E E(T),Ve’ ¢ E(T)

c(8’) é c(e) => C(T + e’ — e) é C(T)-

o In the general method presented above, the way of choosing the
tree Tf is not detailed. We Will discuss two classical strategies for
choosing this tree.

o The ﬁrst strategy chooses Tf as the maximum order tree in the
family TI“.

0 In the second strategy TS,“ is one of the two trees in the family
Tl“, connected by an edge of minimum cost over all edges With
extremities on different trees of the family.

—

o In Kruskal’s algorithm TS,“ is one of the two trees in the family
Tl“, connected by an edge of minimum cost over all edges with
extremities on different trees of the family.

o This choice can be done by performing ﬁrst a non-decreasing sorting
of the edges by their costs and, after that, parsing the obtained list.
If we denote by T the tree Tsk, the algorithm can be described as
follows.

sort E : {e1, e2,...,em} s. t. c(e1) g g c(em);
T <— Q; '1; <— 1;
while (1, g m) do
if (<T U {e¢}>G has no cycles) then
T <— T U {61'};
z‘ + +;
—

Time complexity analysis:
o The are 0(m) calls of the function ﬁnd during the While loop.
o In the sequence of ﬁnd-calls, exactly n — 1 union-calls are
interleaved (one call for each edge of the ﬁnal MST).
o Therefore, the time spent by the algorithm during the while loop
is O(m(9(l) + (n — 1)(9(n)): @(nz).
Hence, the time complexity of the algorithm is C’)(maa:(mlog n, n2)).
If G has many edges, m : (9(n2), then Prim’s algorithm is more efli-
cient.
—

o Hence this form of the algorithm has time complexity Q(n2) (even
if the graph is sparse).

o The weakness of this implementation is given by the fact that, in
the union procedure, we make the root of the new tree that of the
tree storing a smaller number of vertices, implying an augmenting
of h('u) to C(71) during the algorithm.

o We can avoid this by keeping in the root of each tree the cardinality
of the set stored. More precisely, the meaning of pred['u], when 'u
is a root, is:

pred['u] < 0 <:> 'u is the root of the tree
storing a set with — pred['u]vertices ‘
—

The time complexity of the while loop in the above solution is due to the
sequence of ﬁnd calls. Tarjan (1976) observed that a call with h('u) > 1
can, Without changing the O(h('u)) time, "collapse" the tree path from
'u to the root, making h(:n) : 1 for all vertices a: on the path. In this
way, the future ﬁnd calls for these vertices will be faster. More precisely,
the function ﬁnd is:
function ﬁnd('u : V); // 'L', j, aux are local variables.
z' <— 'u;
While (pred[i] > O) do
'1; <— predh];
j <— v;
vvhile (pred[j] > 0) do
aux <- pred[j]; pred[j] k i; j <- auzrz;
return z'; J
—

An edge-cover in G is any set of edges F Q E such that
(115(1))? 1,V'u 6 V(G).

The family of all edge-covers in the graph G is denoted FGz

FG : {F : F Q E,F edge-cover in G}.
Note that FG has the following properties
(i) fG 3i 6 <:> G has no isolated vertices (then E E Fg);
(ii) F Efg,F’Q F:> F’ Efg.
Minimum edge-cover problem:
P2 given a graph G : (V, E), ﬁnd F* E FG such that

|F*| : min |F|
FEFG
—

Let G : (V, E) be a graph and MG the family of its matchings.
Maximum matching problem.
P1 given a graph G : (V, E), ﬁnd M* E MG such that
|M*| : max |M|.
M EM G

o Based on Integer linear programming formulation one can ﬁnd that
the problem P1 is easy if the graph is bipartite.

o Combinatorial adaptation of the simplex algorithm for solving linear
programming problems led to the so called hungarian method for
solving P1 for bipartite graphs.

o We vvill discuss a faster solution: Hopcroft and Karp (1973).

o However, the theorem of duality in linear programming and the
integrity of the optimal solution can be used obtain and explain the
(already proven) results on mathchings in bipartite graphs: ,

—

Exercise 5 (cont’d).
(c) the algorithm doesn't end as long as there are remaining red edges;
(d) the algorithm ends for any choice of the edges e’ and H is the only

minimum cost spanning tree in G.
Exercise 6. Let H be a connected graph, Q qé A Q V(H), and w :
E(H) —> R+. A Steiner tree for (H,A,'w) is a tree T(H,A,'w) :
(VT, ET) Q H with A Q VT which has the minimum weight between
all the trees containing A, and which are subgraphs of H:

s[T(H,A,w>]: Z 10(6):
EEET
: min Z w(e) : Tl : (VT/,ET1) tree in H,A Q VT/
EEETI

(a) Prove that a Steiner tree can be determined in polynomial time

Exercise 11. Let G : (V, E) be a connected graph and c : E —> lR be a

cost function on its edges. True or false? (Justify your answers!)

(a) Any edge of minimum cost in G is contained in a certain minimum
cost spanning tree (MST) of G.

(b) If G has a cycle, G, Whose minimum cost edge is unique on G, then
that edge must be contained in every MST of G.

(c) If an edge is contained in a certain MST of G, then that edge must
-be.9f..lll.illi¥¥ll1¥1.§9§l.il1. a. F?.¢_r.'.?.?i1.1£llli9§.g_:. -. .

Exercise 12. Find the number of maximum matchings in the following

graph:

—


o Note that, if, at some step, there is no edge with an extremity
1h V(Tf) and the other in v \ WTf), it follows that G is hot
connected and there is no MST in G.

o The above construction is suggested in the ﬁgure below:

A A
Tf
Tj; T,’f,k
a The family T"_1 has just one tree, T1714.
—

Proof cont’d.

On the other hand, since c(e*) g c(el), we have c(Tl) : c(Tg) +

c(e*) — c(e1)§ c(TIZ‘).

Because le is a MST of G, it follows that c(Tl) : c(TIj), i. e., Tl is

a MST of G containing all adges in E(Tk+1). By taking T§+1 : T1 we

ﬁnish the proof of the theorem. U
—

Prim’s algorithm

Vs <— {s}; Es <- Q; // for some s 6 V.
for ('u G V \ {5}) do

04M <— s; mu] P c(s'u); // if ij Q E, then c('1lj): oo.
While (VS 5i V) do

ﬁnd j* G V\ Vs s. t. ,8[j*] : 4min 5L1];

J€V\Vs
Vs <— V5 U {j*}§ Es F Es U {a[j*]j*};
for (j e V\ vs) do
if (ﬂm > C[j*j]) then
ﬂU] k C[j*j]; 041'] <—j*;
—

o The array r00t[1..n] with entries from V has the meaning:
'root['u] : root of the tree storing the set to which 'u belongs.
0 Add to the initialization step (corresponding to the family To):
for ('u E V) do
1'00t['u] a 'u;
o The function ﬁnd (having time complexity 0(1)):
function ﬁnd(v : V);
return 'root[v];
o The method union (having time complexity C’)(n)):
method union('u, w : V);
for (i 6 V) do
if (rootm : T00t[’U]) then
moth] : rooﬂw];
—

If we execute this form of the While loop on the graph G : Klmnl with
the sorted edge list, E : {12, 13, ..., 1n}, then the sequence of calls of
the two methods is (F and U abbreviates ﬁnd and union):
F(1),F(2),U(1,2) .1__.2 ---------------------- a”
2 F(1),F(3),U(2,3) .1__2__3 ----------------- on
3 l 2 3 4 n
F(1),F(4),U(3,4) o—-o—-o—-o ——----------- o
n l 2 3 4 nil n
—

o In this while iteration we have a call of the method union. Let
uni0n(ac, y) be this call, and suppose that in the union method the
assignement pred[y] <— a: is executed. This means that before this
iteration we have —pred[a:] Z —pred[y].

The vertices 'u for which h('u) changes in this iteration are those
for which, before the iteration we had ﬁnd('u) : y and —p'red[y] 2
2W).
After the while loop iteration, we have h’(v) : h('u) + 1 and
ﬁnd’('u) : a3. Hence, we must verify if —pred’[:z:] 2 2W”). In-
deed, —pred’[a:] : —pred[:n] —pred[y] 2 2- (-pred[y]) Z 2 - 2M”) :
2h(v)+1 z 2h’(v)_

It follows that (*) is an invariant of the algorithm. D /

—

Maximum matching problem:
P1 given a graph G : (V, E), ﬁnd M* E MG such that
|M*| : max |M|
MGM G
We denote 1/(G) : max lMl.
MEMG
The maximum matching problem is closely related to the minimum edge-
cover problem.
—

Proof cont’d.

Obviously, the algorithm builds a matching M in G. If the edge e

incident with 'u (and removed from M in a while iteration) is e : m)’,

then dM(v’) : 1 and in the next iteration we will have dM('u’) : 0, hence

at each while iteration an exposed vertex w.r.t. the ﬁnal matching M is

created (if there would be another edge e’ in the current set M incident

with 'u’, then, since e G F*, it follows that F* \ {e} would be an edge-

cover, contradicting the choice of F*).

Hence, if M is the matching constructed by the algorithm, then lF*l —

lM| : lE(M)l :n—2-lMl, i. e.,

(3) lF*l:n—lMl>n—lM*l-

From (2) and (3) the theorem follows. D
—

Exercise 3. Let G : (V, E) be a connected graph and c : R —> R. For
any spanning tree T : (V,E’) G Tg, and 'u 73 'w G V we denote by
Pg” the unique 'u'w-path in T. Show that a spanning tree T* : (V, E*)
has a minimum cost if and only if

Ve:vw€E\E*,Ve'€E(P$;), we have c(e)> C(e’). ,
Exercise 4. Let G : (V, E) be a 2-edge-connected graph and c : E —> R.
If T : (V, E’) is minimum cost spanning tree of G and e 6 E’, T — e
has exactly two connected components T{ and Té respectively. We
denote by eT 75 e a minimum weight edge in the cut generated by
(V(T{), V(Té)) in G— e. Show that, if T* is a minimum cost spanning
tree of G, and e E E(T*), then T*— e+eT* is a minimum cost spanning
tree of G — e. ,

—

Exercise 8. Let G : (V, E) be a connected graph and c : E —> R a cost
function on its edges.
a) Let T* be a minimum c-cost spanning tree of G and e > 0. Prove
that T* is the only minimum E-cost spanning tree of G, Where
a8) z c(e) — e, if e E E(T*)
c( e), otherw1se
b) Deduce from here that for every minimum spanning tree, T*, of G
there exists an ordering of the edges in G such that Kruskal’s algorithm
returns T*.
Exercise 9. Let G be a graph, 5,156 V, and c : E(G) —> 1R+ a cost on
its edges. For every path (with non-zero length) vve deﬁne its bottleneck
as the minimum cost of its edges. Design an eﬁicient algorithm which
ﬁnds a st-path with the maximum bottleneck; (among all st-paths in G). ,
—

